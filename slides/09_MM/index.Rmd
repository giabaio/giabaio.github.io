---
title: "&#8291;9. Markov models"
author: Gianluca Baio
institute: "[Department of Statistical Science](https://www.ucl.ac.uk/statistics/) | University College London"
params: 
   - conference: "STAT0019 - Bayesian Methods in Health Economics"
   - location: "UCL"
date: 
output:
  xaringan::moon_reader:
    includes: 
       in_header: "../assets/latex_macros.html" 
       ## This line adds a logo based on the format selected in the file 'assets/THEME/include_logo.html'
       ## NB: the actual options (eg placement of the logo and actual logo file) can be changed there
       ## There's also a script to manipulate the colouring scheme for the UCL logo (from a basic black/white one)
       after_body: "../assets/ucl-stats/insert-logo.html"
    seal: false
    yolo: no
    lib_dir: libs
    nature:
      beforeInit: ["https://platform.twitter.com/widgets.js"]
      highlightStyle: github
      highlightLines: yes
      countIncrementalSlides: no
      ratio: '16:9'
      titleSlideClass:
      - center
      - middle
    self_contained: false 
    css:
    - "../assets/ucl-stats.css"
---

```{r echo=F,message=FALSE,warning=FALSE,comment=NA}
# Sources the R file with all the relevant setup and commands
source("../assets/setup.R")

# Stuff from 'xaringanExtra' (https://pkg.garrickadenbuie.com/xaringanExtra)
# This allows the use of panels (from 'xaringanExtra')
xaringanExtra::use_panelset()
# This allows to copy code from the slides directly
xaringanExtra::use_clipboard()
# This freezes the frame for when there's a gif included
xaringanExtra::use_freezeframe()

# Defines the path to the file with the .bib entries (in case there are references)
bibfile=ReadBib("~/Dropbox/Perso/Office/CV/mypubs.bib",check = FALSE)
```

class: title-slide

# `r rmarkdown::metadata$title`

## `r rmarkdown::metadata$author`

### `r rmarkdown::metadata$institute`    

.title-small[
`r icons::icon_style(icons::fontawesome("envelope",style = "solid"),scale=.8,fill="#00acee")`  [g.baio@ucl.ac.uk](mailto:g.baio@ucl.ac.uk)
`r icons::icon_style(icons::fontawesome("firefox"),scale=.8,fill="#EA7600")`  [https://gianluca.statistica.it/](https://gianluca.statistica.it/)
`r icons::icon_style(icons::fontawesome("firefox"),scale=.8,fill="#EA7600")`  [https://egon.stats.ucl.ac.uk/research/statistics-health-economics/](https://egon.stats.ucl.ac.uk/research/statistics-health-economics/)
`r icons::icon_style(icons::fontawesome("github"),scale=.8,fill="black")`  [https://github.com/giabaio](https://github.com/giabaio)
`r icons::icon_style(icons::fontawesome("github"),scale=.8,fill="black")`  [https://github.com/StatisticsHealthEconomics](https://github.com/StatisticsHealthEconomics)
`r icons::icon_style(icons::fontawesome("twitter"),scale=.8,fill="#00acee")`  [@gianlubaio](https://twitter.com/gianlubaio)     
]

### `r rmarkdown::metadata$params`

<!--
Adds a departmental logo on the right-bottom corner (Only with 'ucl-stats')
-->
.logo-stats[]

<!--
Can also add sticky notes:
`r postit(text=paste0('Check out our departmental podcast "Random Talks" on Soundcloud!', add_podcast()),top="75%",left="2.5%",height="6.3em",width="6.3em")`

`r postit(text=paste0("Follow our departmental social media accounts", add_twitter(url="https://twitter.com/stats_ucl",title="@stats_UCL",fill="#00acee"), add_linkedin(url="https://www.linkedin.com/in/statistical-science-ucl-906b9a201",title="LinkedIn")),top="53%",left="6.5%",height="6.3em",width="6.3em")`
-->

<!-- This adds a footer (optional and with other possibilities...) 
     For example, can use `r samptux()` to add the Samp Tux log,
     or change the bottom space to align the text, etc
.footer-left[
<span style="position: relative; bottom: 0px; color: #D5D5D5;"> &nbsp; &copy; Gianluca Baio (UCL)</span>
]
--> 


---

layout: true

.my-footer[ 
.alignleft[
&nbsp; &copy; Gianluca Baio (UCL) `r add_twitter()` `r add_github()` `r add_email()` `r add_website()`
]
.aligncenter[
`r rmarkdown::metadata$title` 
]
.alignright[
`r course_site()` &nbsp; STAT0019 
]
] 

---


# Summary

- Assess .red[**long-term**] cost-effectiveness based only on .red[**short-term**] data

- State-transition (usually *Markov*) models for clinical histories

- Commonly implemented in `Excel`, or specialized software (eg `TreeAge`)

- Bayesian framework lets you .red[simultaneously] perform
   - parameter estimation (from short-term data, eg meta-analysis), and
   - probabilistic sensitivity analysis (long-term costs and benefits)
   - uncertainty about parameters fully included

- Example: 3-state cancer Markov model

- Markov models & survival analysis

`r vspace("4em")`

.content-box-beamer[
### **References** 

`r vspace("20px")`

`r bmhe(5.5)`

`r briggs()`

`r esdm()`

`r bcea_book()`

]

---

# Markov models

- Assume a set $\mathcal{S}$ made of $S$ "clinically relevant" states
   - Exhaustive and mutually exclusive
   
- The structure (links among nodes) describes the dynamics of disease history
   - Arrows connecting two states encode the assumption that a transition from the one where the arrow originates to the one reached by it is possible
   - Absence of an arrow between two states implies that the transition from one to the other is not allowed by our model
   
--

- From one period to the next, subjects can move among the states according to the rules specified by the arrows

- Movements occur according to suitable transition probabilities
$$\color{#24568c}\bm\pi_j = \bm\pi_{j-1} \bm\Lambda_j$$
   where
   - $\bm\pi_j=(\pi_{1j},\ldots,\pi_{Sj})$ is the vector of probabilities for each state at time $j$
   - $\bm\Lambda_j = [\Lambda_{j;s',s}]$ is a transition matrix describing the probability of moving from state $s$ to state $s'$ at time $j$

--

- **NB** the matrix algebra simply computes for each state $s$

$$\color{blue}{\Pr(`r sftext("Being in state ")` s `r sftext(" at time ")` j)= \sum_{s'\in\mathcal{S}}\Pr(`r sftext("Being in state ")` s' `r sftext(" at time ")` j-1)\times \Pr(`r sftext("Moving from state ")`s'`r sftext(" to state ")`s)}$$

---

count: false
# Markov models

### 1. Define a structure .alignright[("**Natural history**" of the disease)]

`r include_fig("09_MM_5.png",width="58%",title="A basic Markov model structure")`

---

count: false
# Markov model

### 2. Estimate the transition probabilities

`r include_fig("09_MM_6.png",width="65%",title="A basic Markov model structure")`

`r vspace("-20px")`
For instance: 

- $\lambda_{14} =$ general (healthy) population mortality $\Rightarrow$ Relevant data: Life tables/official records, . . .
- $\lambda_{24} =$ disease-specific mortality $\Rightarrow$ Relevant data: Trial/observational studies, . . .
- $\ldots$

---

count: false
# Markov model

### 3. Run the simulation: $j=0$

`r include_fig("09_MM_7.png",width="65%",title="Typically, at the beginning of the simulation, every individual is in the 'null' state (eg healthy)")`

`r vspace("20px")`
Distribute the "virtual cohort" across the $S$ states (typically, everybody starts in the "healthy" state...)

---

count: false
# Markov model

### 3. Run the simulation: $j=1$

`r include_fig("09_MM_8.png",width="65%",title="...Then, they start to move around, according to the transition probabilities...")`

`r vspace("20px")`
Start moving people around...

---

count: false
# Markov model

## Matrix algebra and "state occupancy"

- $m_{sj}$ is the **number** of people in state $s$ at time $j$

- $\lambda_{s'sj}$ is the probability of moving from state $s'$ to state $s$ between time $j$ and $j+1$

`r vspace("20px")`   
- Thus:
$$\color{#24568c}{m_{s\, j+1} = m_{1j}\lambda_{1sj} + m_{2j}\lambda_{2sj} + \ldots + m_{Sj}\lambda_{Ssj}}$$
   which we can write in matrix algebra as
\begin{align}
\color{#24568c}{(m_{1\, j+1},\ldots,m_{S\, j+1})} & \color{#24568c}{=\, (m_{1\, j},\ldots,m_{S\, j})\left(\begin{array}{ccc}\lambda_{11j} & \ldots & \lambda_{1Sj} \\ \vdots & \ddots & \vdots \\ \lambda_{S1j} & \ldots & \lambda_{SSj}  \end{array}\right)} \\
\color{#24568c}{\bm{m}_{j+1}} & \color{#24568c}{= \, \bm{m}_{j} \bm\Lambda_j}
\end{align}

`r vspace("30px")`   
- **NB**: The transition matrix typically does depend on the time $j$, but sometimes we can relax this assumption

---

count: false
# Markov model

### 3. Run the simulation: $j=2$

`r include_fig("09_MM_9.png",width="65%",title="...They continue to move: for instance, more people are being affected by the disease and die...")`

`r vspace("20px")`

Move people around according to the relationship $\bm{m}_{2}=\bm{m}_{1}\bm\Lambda_{1}$

---

count: false
# Markov model

### 3. Run the simulation: $j=3$

`r include_fig("09_MM_10.png",width="65%",title="...More of the same...")`

`r vspace("20px")`

Move people around according to the relationship $\bm{m}_{3}=\bm{m}_{2}\bm\Lambda_{2}$
---

count: false
# Markov model

### 3. Run the simulation: $j=J$ .alignright[("*lifetime* horizon")]

`r include_fig("09_MM_11.png",width="65%",title="...And if the virtual follow up (length of the simulation) is long enough, then everybody will have moved to the absorbing state (death, in this case)")`

---

#  Cost-effectiveness modelling

1. Assign .red[**benefits**] & .blue[**costs**] to each state in the model and for each treatment $t$ under study: $\color{black}{(e_{ts},c_{ts})}$
   - A measure of QoL (e.g. QALYs associated with being "perfectly healthy") 
   - A measure of cost (e.g. what does it cost the NHS for every person who has the disease?)

2. "Cohort simulation": estimate the proportion of individuals in each state at each time point (cycle)
   - Usually need to do this for a long enough "virtual follow up" so that everybody reach the "absorbing state" 
   - That's a state from which you never move out (e.g. death)
   
3. For each treatment $t$ under study, accumulate costs and benefits over time (slightly abusing the notation...)
\begin{align}
\color{red}e_t\, & \color{red}= \, \sum_{j=0}^J \sum_{s=1}^S m_{tsj}e_{ts} & & \color{black}`r sftext(" and ")` & & & \color{blue}c_t\, & \color{blue} =\, \sum_{j=1}^J \sum_{s=1}^S m_{tsj}c_{ts} \\
& \color{red}\,= \, \sum_{j=0}^J e_{tj} & & & & & \, & \color{blue}= \, \sum_{j=0}^J c_{tj}
\end{align}

   **NB**: Costs and benefits can also be modelled to describe the uncertainty around their value
      - **For example**: QALYs over one year $\sim\dbeta(a,b)$; Costs $\sim\dgamma(\gamma,\rho)$; $\ldots$
      - These may be informed by individual level data (see  `r ref_lecture("ild")`) or evidence synthesis (see  `r ref_lecture("ald")`)

---

count: false
# Cost-effectiveness modelling

## Discounting .alignright[See BMHE, chapter 1.5; 5.4]

- Costs and outcomes can occur at different times with respect to when the intervention is implemented

- **But**: society tends to value benefits that arrive closer to the present time more than those that will be achievable in the (possibly very distant) future

  - Example: Human Papilloma Virus (HPV) vaccination is available for boys and girls as young as 12, but benefits (protection from cervical cancer) only materialises when they are well in their 40s...
  
--


- .red[**Discounting**] accounts for differential timing by reducing the value of costs and effects in the future

   - Particularly relevant for economic evaluation spanning over a time horizon $>$ 1 time unit (e.g. year) 
   
   - Markov models tend to do that, so discounting is a key issue when using them!
   
- Define a **discount rate** $d$ to ensure that costs sustained and benefits gained closer to now have more value
   
- Compute the **Present Value** of intervention $t$ as 

\begin{align}
\color{red}`r sftext("PV")`_t^e = \sum_{j=0}^J \frac{e_{tj}}{(1+d)^j} \qquad \color{black}`r sftext(" and ")` \qquad \color{blue}`r sftext("PV")`_t^c = \sum_{j=0}^J \frac{c_{tj}}{(1+d)^j}
\end{align}

- NICE suggests using $d=3.5\%$ for costs and outcomes &ndash; but for some diseases can use different rates for costs and benefits...

---

# Example

## 3-state cancer Markov model

- This is one of the most popular structures developed as Markov models

```{r 3state, engine='tikz', echo=F, out.width="85%",opts=list(width="75%",title="INSERT TEXT HERE"), eval=FALSE}
\input{../assets/latex_colours.tex}
\usetikzlibrary{shapes,arrows,arrows.meta,decorations.pathreplacing,shapes.geometric}

\begin{tikzpicture}
\draw(0,2) node[align=center,ellipse,draw,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](1){Progression};
\draw(-2.5,0) node[align=center,ellipse,draw,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](2){Pre progression};
\draw(2.5,0) node[align=center,ellipse,draw,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](3){Death};

\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (2.40) -- (1.200);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (2.east) -- (3.west);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (1.330) -- (3.140);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (1) to [out=190, in=170, looseness=3.5] (1);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (2) to [out=188, in=173, looseness=3.5] (2);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (3) to [out=345, in=20, looseness=3.5] (3);

\draw(-4.5,0) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](6){$\lambda_{11}$};
\draw(-1.65,1.15) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](7){$\lambda_{12}$};
\draw(.4,.2) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](9){$\lambda_{13}$};
\draw(-1.7,2.1) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](5){$\lambda_{22}$};
\draw(1.6,1.15) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](8){$\lambda_{23}$};
\draw(4,0) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](10){$\lambda_{33}$};

%\draw(2.55,-.5) node[align=center,fill=none,font=\sffamily\fontsize{6}{7}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=red!70](10){$\pi_{3}^{(t)}=1-\mbox{OS}(t)$};
%\draw(-2.55,-.5) node[align=center,fill=none,font=\sffamily\fontsize{6}{7}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=red!70](6){$\pi_{1}^{(t)}=\mbox{PFS}(t)$};
%\draw(.15,2.5) node[align=center,fill=none,font=\sffamily\fontsize{6}{7}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=red!70](6){$\pi_{2}^{(t)}=\mbox{OS}(t)-\mbox{PFS}(t)$};
\end{tikzpicture}
```

`r include_fig("3state-1.png",width="85%")`

`r vspace("50px")`
- Patients typically enter the cohort in "pre-progression"
- Then can either die or "progress" to a worst condition
- From there they typically cannot revert to a better state

---

count: false
# Example

## 3-state cancer Markov model

**Ideally**, we can access individual level data (e.g. from a randomised trial), describing the "event history" for each patient
```{r echo=FALSE}
library(kableExtra)
data=read.table("~/Dropbox/UCL/3021/Practicals/10_markov/williams-et-al/data.txt",header=T,sep="\t") %>% as_tibble() %>% 
  mutate(
    # Create a patient ID for convienience
    patid=row_number(),
    # Convert times from months to years
    prog_ty=prog_t/12,
    death_ty=death_t/12,
    progdeath_ty=progdeath_t/12,
    # Create competing risk indicator
    # 0=did not die or have a progression, 1=had a progression, 2=died without progression
    crstatus=case_when(
      prog==1~1,
      (prog==0 & death)==1~2,
      TRUE~0
    )
  )

options(knitr.kable.NA = "\\(\\ldots\\)")

tab=data %>% select(patid,treat,prog,death,prog_t,death_t) %>% slice(c(1,2)) %>% 
   add_row(patid=NA,treat=NA,prog=NA,death=NA,prog_t=NA,death_t=NA) %>% 
   bind_rows(tab=data %>% select(patid,treat,prog,death,prog_t,death_t) %>% slice(c(10,11))) %>% 
   add_row(patid=NA,treat=NA,prog=NA,death=NA,prog_t=NA,death_t=NA)
tab %>% kable(col.names=c("Patient","Treatment","Progression?","Death?","Progression time","Death time"),align="c",digits=2) %>% 
   kable_classic() %>% 
   column_spec(1:6,width="1.5cm") %>% 
   kable_styling(full_width=F) %>% 
   row_spec(nrow(tab),extra_css="border-bottom: 2px solid;")

```

`r vspace("30px")`

This type of data would allow us to estimate **directly** all the relevant transition probabilities (with some extra work...)

   - They contain information about the .blue[**complete history**] of each individual and so we can use them to construct the "risk set" for each possible transition and then estimate the time-to-event

---

# Reconstructing the data

## Subset 1: Progression

- Risk set: all individuals who are at risk of making progression

   - The individuals in the risk set may or may not also die ("competing risks")
   - But we consider "Progression" as the **event** and "Death" or "No progression" as **censoring**

.panelset[

.panel[
.panel-name[Code]
```{r,echo=TRUE,eval=FALSE}
  data %>% mutate(
  id=patid,                             # patient ID
  from=1,                               # starting state
  to=2,                                 # arriving state 
  trans=1,                              # transition code (1 = Pre -> Progression) 
  Tstart=0,                             # entry time
  Tstop=prog_t,                         # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    prog==1~1,                          #  1 if progressed; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% 
  # Selects only the relevant rows
   select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat)
```
]

.panel[
.panel-name[Output]
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,
  from=1,           # starting state
  to=2,             # arriving state 
  trans=1,          # transition code (1 = Pre -> Progression)
  Tstart=0,         # entry time
  Tstop=prog_t,     # exit time
  time=prog_t,      # time-to-event = Tstop-Tstart
  status=case_when(
    prog==0~0,      # censoring indicator: 1 if progressed; 0 otherwise
    TRUE~1
  ),
  treat=treat       # treatment arm
) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% slice(sample(nrow(.)))
```
]

.panel[
.panel-name[Examples (1)]
Patients who have progressed but not died, e.g.
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,
  from=1,           # starting state
  to=2,             # arriving state 
  trans=1,          # transition code (1 = Pre -> Progression)
  Tstart=0,         # entry time
  Tstop=prog_t,     # exit time
  time=prog_t,      # time-to-event = Tstop-Tstart
  status=case_when(
    prog==0~0,      # censoring indicator: 1 if progressed; 0 otherwise
    TRUE~1
  ),
  treat=treat       # treatment arm
) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==1,death==0) %>% slice(1)
```

Patients who have died *at* or *after* progression, e.g.
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,
  from=1,           # starting state
  to=2,             # arriving state 
  trans=1,          # transition code (1 = Pre -> Progression)
  Tstart=0,         # entry time
  Tstop=prog_t,     # exit time
  time=prog_t,      # time-to-event = Tstop-Tstart
  status=case_when(
    prog==0~0,      # censoring indicator: 1 if progressed; 0 otherwise
    TRUE~1
  ),
  treat=treat       # treatment arm
) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==1,death==1) %>% slice(c(1,21))
```
]


.panel[
.panel-name[Examples (2)]
Patients who have died before progression (NB: these are **censored** in this case!)
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,
  from=1,           # starting state
  to=2,             # arriving state 
  trans=1,          # transition code (1 = Pre -> Progression)
  Tstart=0,         # entry time
  Tstop=prog_t,     # exit time
  time=prog_t,      # time-to-event = Tstop-Tstart
  status=case_when(
    prog==0~0,      # censoring indicator: 1 if progressed; 0 otherwise
    TRUE~1
  ),
  treat=treat       # treatment arm
) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==0,death==1) %>% slice(1:2)
```


Patients who have been fully censored 
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,
  from=1,           # starting state
  to=2,             # arriving state 
  trans=1,          # transition code (1 = Pre -> Progression)
  Tstart=0,         # entry time
  Tstop=prog_t,     # exit time
  time=prog_t,      # time-to-event = Tstop-Tstart
  status=case_when(
    prog==0~0,      # censoring indicator: 1 if progressed; 0 otherwise
    TRUE~1
  ),
  treat=treat       # treatment arm       
) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==0,death==0) %>% slice(1:2)
```

]
]   

---

count: false
# Reconstructing the data

## Subset 2: Death from pre-progression

- Risk set: all individuals who are at risk of dying

   - The individuals in the risk set may or may not also progress ("competing risks")
   - But we consider "Death" as the **event** and "Progression" or "No progression" as **censoring**

.panelset[

.panel[
.panel-name[Code]
```{r,echo=TRUE,eval=FALSE}
  data %>% mutate(
  id=patid,                             # patient ID
  from=1,                               # starting state
  to=3,                                 # arriving state 
  trans=2,                              # transition code (2 = Pre -> Death)  
  Tstart=0,                             # entry time
  Tstop=prog_t,                         # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    (death==1 & prog_t==death_t)~1,     #  1 if died at progression; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% 
  # Selects only the relevant rows
   select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat)
```
]

.panel[
.panel-name[Output]
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,                             # patient ID
  from=1,                               # starting state
  to=3,                                 # arriving state 
  trans=2,                              # transition code (2 = Pre -> Death)  #<<
  Tstart=0,                             # entry time
  Tstop=prog_t,                         # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    (death==1 & prog_t==death_t)~1,     #  1 if died at progression; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% 
  # Selects only the relevant rows
   select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% slice(sample(nrow(.)))
```
]

.panel[
.panel-name[Examples (1)]
Patients who have progressed, but not died, e.g. 
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,                             # patient ID
  from=1,                               # starting state
  to=3,                                 # arriving state 
  trans=2,                              # transition code (2 = Pre -> Death)  #<<
  Tstart=0,                             # entry time
  Tstop=prog_t,                         # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    (death==1 & prog_t==death_t)~1,     #  1 if died at progression; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==1,death==0) %>% slice(1)
```

Patients who have died *at* or *after* progression (NB: these are **censored** in this case!), e.g.
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,                             # patient ID
  from=1,                               # starting state
  to=3,                                 # arriving state 
  trans=2,                              # transition code (2 = Pre -> Death)  #<<
  Tstart=0,                             # entry time
  Tstop=prog_t,                         # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    (death==1 & prog_t==death_t)~1,     #  1 if died at progression; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  )%>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==1,death==1) %>% slice(c(1,21))
```
]


.panel[
.panel-name[Examples (2)]
Patients who have died before progression
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,                             # patient ID
  from=1,                               # starting state
  to=3,                                 # arriving state 
  trans=2,                              # transition code (2 = Pre -> Death)  
  Tstart=0,                             # entry time
  Tstop=prog_t,                         # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    (death==1 & prog_t==death_t)~1,     #  1 if died at progression; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==0,death==1) %>% slice(1:2)
```


Patients who have been fully censored
```{r,echo=FALSE,eval=TRUE}
  data %>% mutate(
  id=patid,                             # patient ID
  from=1,                               # starting state
  to=3,                                 # arriving state 
  trans=2,                              # transition code (2 = Pre -> Death)  #<<
  Tstart=0,                             # entry time
  Tstop=prog_t,                         # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    (death==1 & prog_t==death_t)~1,     #  1 if died at progression; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==0,death==0) %>% slice(1:2)
```

]
]   

---

count: false
# Reconstructing the data

## Subset 3: Death from progression

- Risk set: all individuals who have progressed and are at risk of dying

   - The individuals in the risk set have certainly progressed and may or may not also die 
   - But we consider "Death" as the **event** and "No death" as **censoring**


.panelset[

.panel[
.panel-name[Code]
```{r,echo=TRUE,eval=FALSE}
  data %>% filter(prog==1) %>% mutate(  # NB: Filter for patients who *have* progressed! #<<
  id=patid,                             # patient ID
  from=2,                               # starting state
  to=3,                                 # arriving state 
  trans=3,                              # transition code (2 = Pre -> Death)  
  Tstart=prog_t,                        # entry time
  Tstop=death_t,                        # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    death==1~1,                         #  1 if died; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% 
  # Selects only the relevant rows
   select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat)
```
]

.panel[
.panel-name[Output]
```{r,echo=FALSE,eval=TRUE}
  data %>% filter(prog==1) %>% mutate(
  id=patid,                             # patient ID
  from=2,                               # starting state
  to=3,                                 # arriving state 
  trans=3,                              # transition code (2 = Pre -> Death)  #<<
  Tstart=prog_t,                        # entry time
  Tstop=death_t,                        # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    death==1~1,                         #  1 if died; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% 
  # Selects only the relevant rows
   select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% slice(sample(nrow(.)))
```
]

.panel[
.panel-name[Examples (1)]
Patients who have died after progression, e.g. 
```{r,echo=FALSE,eval=TRUE}
  data %>% filter(prog==1) %>% mutate(
  id=patid,                             # patient ID
  from=2,                               # starting state
  to=3,                                 # arriving state 
  trans=3,                              # transition code (2 = Pre -> Death)  #<<
  Tstart=prog_t,                        # entry time
  Tstop=death_t,                        # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    death==1~1,                         #  1 if died; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==1,death==1) %>% slice(1)
```

Patients who have not died (NB: these are **censored** in this case!), e.g.
```{r,echo=FALSE,eval=TRUE}
  data %>% filter(prog==1) %>% mutate(
  id=patid,                             # patient ID
  from=2,                               # starting state
  to=3,                                 # arriving state 
  trans=3,                              # transition code (2 = Pre -> Death)  #<<
  Tstart=prog_t,                        # entry time
  Tstop=death_t,                        # exit time
  time=Tstop-Tstart,                    # time-to-event = Tstop-Tstart
  status=case_when(                     # censoring indicator: 
    death==1~1,                         #  1 if died; 0 otherwise
    TRUE~0
  ),
  treat=treat                           # treatment arm
  ) %>% select(id,from,to,trans,Tstart,Tstop,time,prog,death,status,treat,prog_t,death_t) %>% 
   filter(prog==1,death==0) %>% slice(1)
```
]

]

---

# Example

## Estimating the survival curves

```{r echo=FALSE}
subdata1=data %>% mutate(
  id=patid,
  from=1,
  to=2,
  trans=1,
  Tstart=0,
  Tstop=prog_t,
  time=Tstop-Tstart,
  status=case_when(
    prog==0~0,
    TRUE~1
  ),
  treat=treat
) %>% select(id,from,to,trans,Tstart,Tstop,time,status,treat) 

subdata2=data %>% mutate(
      id=patid,
      from=1,
      to=3,
      trans=2,
      Tstart=0,
      Tstop=prog_t,
      time=Tstop-Tstart,
      status=case_when(
        (death==1 & prog_t==death_t)~1,
        TRUE~0
      ),
      treat=treat
    ) %>% select(id,from,to,trans,Tstart,Tstop,time,status,treat) 

subdata3=data %>% filter(prog==1) %>% mutate(
      id=patid,
      from=2,
      to=3,
      trans=3,
      Tstart=prog_t,
      Tstop=death_t,
      time=death_t-prog_t,
      status=case_when(
        death==1~1,
        TRUE~0
      ),
      treat=treat
    ) %>% select(id,from,to,trans,Tstart,Tstop,time,status,treat) 
```

- We can use the models we saw in `r ref_lecture("survival")` to estimate the survival curves for the 3 subsets
- For example, we can test various alternative and settle for a Gompertz distribution

```{r echo=TRUE,message=FALSE,results="hide",cache=TRUE}
# Sets up informative priors on the Gompertz parameters to stabilise inference
priors=list(gom=list(a_alpha=1.5,b_alpha=1.5))

# Runs survival models on the specific subsets to obtain estimate of the various transition probabilities
m_12=fit.models(Surv(time,status)~as.factor(treat),data=subdata1,distr="gom",method="hmc",priors=priors)
m_13=fit.models(Surv(time,status)~as.factor(treat),data=subdata2,distr="gom",method="hmc",priors=priors)
m_23=fit.models(Surv(time,status)~as.factor(treat),data=subdata3,distr="gom",method="hmc",priors=priors)

```

- Now can use the simulated values for the survival curves to *approximate* the transition probabilities

   - Technically, the models above estimate survival over continuous times, while the Markov model assumes discrete cycles
   
- Can use the `survHE` function `make.surv` to generate simulations from the survival curves from each model over any arbitrary extrapolation

---

# Survival curves and transition probabilities
```{r survival1,fig.width=15,fig.height=5,echo=FALSE,opts=list(width="100%"),eval=TRUE}
p1=plot(m_12,t=seq(0,120),add.km=T,main="Progression")
p2=plot(m_13,t=seq(0,120),add.km=T,main="Death from pre-progression")
p3=plot(m_23,t=seq(0,120),add.km=T,main="Death from progression")

gridExtra::grid.arrange(p1,p2,p3,nrow=1,ncol=3,widths=c(12,12,12),heights=7)
```

In general, given a survival curve representing a suitable transition, we can compute
$$\color{#24568c}\lambda_{s'sj}\approx 1-\frac{S_{j+k}}{S_j}$$
`r vspace("-15px")`
(intuitively, the transition probability can be read off as the reduction in the proportion of individuals who have *not* experienced the event between two consecutive times)

---

count: false
# Survival curves and transition probabilities 

We can **directly** estimate

- $\lambda_{12j}$ from the survival curves derived with subset 1
- $\lambda_{13j}$ from the survival curves derived with subset 2
- $\lambda_{23j}$ from the survival curves derived with subset 3


**Indirectly** (using the fact that the transitions are mutually exclusive and exhaustive)

- $\lambda_{11j}=1-\lambda_{12j}-\lambda_{13j}$
- $\lambda_{22j}=1-\lambda_{23j}$


And because "Death" is an absorbing state, we can complete the transition matrix

\begin{align}
\color{#24568c}\bm\Lambda_j = \left(\begin{array}{ccc} \lambda_{11j} & \lambda_{12j} & \lambda_{13j} \\ 0 & \lambda_{22j} & \lambda_{23j} \\ 0 & 0 & 1 \end{array}\right)
\end{align}

`r vspace("30px")`

We can also replicate this calculation for $n_{sim}$ times to propagate the uncertainty in the survival curves onto the whole Markov model

`r vspace("20px")`
**NB**: May need more complex modelling (see for instance `r icon::academicons$pubmed` [Williams et al, 2017](https://pubmed.ncbi.nlm.nih.gov/27698003/))

---

# Running the Markov model

We can finally run the Markov model by initialising the state occupancy $\bm{m}_0$ and simply apply the matrix algebra to determine the number of people in each state at each time point.

```{r echo=FALSE,fig.width=14,fig.height=6,opts=list(width="95%"),eval=FALSE}
s_12=make.surv(m_12,t=seq(0,120))
s_13=make.surv(m_13,t=seq(0,120))
s_23=make.surv(m_23,t=seq(0,120))
time=seq(0,120)
nsim=1
# Estimate for lambda_12
lambda_12=s_12$mat %>% bind_rows() %>% mutate(treat=rep(c(1,2),each=length(time))) %>% select(treat,everything()) %>% 
  group_by(treat) %>% mutate(across(starts_with("S"),~1-./lag(.))) %>% tidyr::drop_na() %>% ungroup() %>% 
  rename_with(starts_with("S"),.fn=~paste0("p",1:nsim))

# Estimate for lambda_13
lambda_13=s_13$mat %>% bind_rows() %>% mutate(treat=rep(c(1,2),each=length(time))) %>% select(treat,everything()) %>% 
  group_by(treat) %>% mutate(across(starts_with("S"),~1-./lag(.))) %>% tidyr::drop_na() %>% ungroup() %>% 
  rename_with(starts_with("S"),.fn=~paste0("p",1:nsim))

# Derives lambda_11 by substraction (as all transition probs out of state 1 must sum to 1)
lambda_11=(lambda_12 %>% select(starts_with("p"))+lambda_13 %>% select(starts_with("p"))) %>% as_tibble() %>% 
  bind_cols(lambda_12 %>% select(treat,t)) %>% select(treat,t,everything()) %>% 
  mutate(across(starts_with("p"),~1-.))

# Estimate for lambda_23
lambda_23=s_23$mat %>% bind_rows() %>% mutate(treat=rep(c(1,2),each=length(time))) %>% select(treat,everything()) %>% 
  group_by(treat) %>% mutate(across(starts_with("S"),~1-./lag(.))) %>% tidyr::drop_na() %>% ungroup() %>% 
  rename_with(starts_with("S"),.fn=~paste0("p",1:nsim))

# Derives lambda_22 by substraction (as all transition probs out of state 2 must sum to 1)
lambda_22=(1-lambda_23 %>% select(starts_with("p"))) %>% as_tibble() %>% 
  bind_cols(lambda_23 %>% select(treat,t)) %>% select(treat,t,everything())


## Now can construct the Markov model based on these transitions 
##  all probabilities are available and estimated with uncertainty accounted for

# Builds up the time-specific transition matrices
Lambda=list(list(),list())
for (i in 1:2) {
  for (j in 1:length(time[-1])) {
    Lambda[[i]][[j]]=matrix(c(
      lambda_11 %>% filter(treat==i) %>% slice(j) %>% pull(p1),
      lambda_12 %>% filter(treat==i) %>% slice(j) %>% pull(p1),
      lambda_13 %>% filter(treat==i) %>% slice(j) %>% pull(p1),
      0,
      lambda_22 %>% filter(treat==i) %>% slice(j) %>% pull(p1),
      lambda_23 %>% filter(treat==i) %>% slice(j) %>% pull(p1),
      0,
      0,
      1
    ),nrow=3,ncol=3,byrow=T)
    colnames(Lambda[[i]][[j]])=rownames(Lambda[[i]][[j]])=c("Pre","Post","Death")
  }
}

# Initialise population
m=list(list(),list())
# At the beginning, everyone is in the 'pre' state
m[[1]][[1]]=m[[2]][[1]]=matrix(c(1000,0,0),nrow=1,ncol=3)
# Then run the MM using the equation
for (i in 1:2) {
  for (j in 2:length(Lambda[[1]])) {
    m[[i]][[j]]=m[[i]][[j-1]]%*%Lambda[[i]][[j]]
  }
}

tibble(
  treat="Intervention",
  cycle=rep(1:length(m[[1]]),each=3),
  group=rep(c("Pre","Post","Death"),length(m[[1]])),
  npeople=unlist(m[[1]])
) %>% bind_rows(
  tibble(
    treat="Control",
    cycle=rep(1:length(m[[2]]),each=3),
    group=rep(c("Pre","Post","Death"),length(m[[2]])),
    npeople=unlist(m[[2]])
  )
) %>% ggplot(aes(x=cycle,y=npeople,fill=group))+geom_bar(position="stack",stat="identity") +
  labs(x="Cycle",y="Number of people",title="Markov trace",fill="State") +
  facet_wrap(~treat)

```

`r include_fig("unnamed-chunk-21-1.png",width="95%")`

---

# Summary so far

## If we have the individual level data...
- In that case, we can recreate direct estimates of all the relevant transition probabilities

   - In that case, running the Markov model is basically just a problem of matrix algebra
   
   - Modellers tend to do this using a combination of statistical software (for the survival analysis) and spreadsheet (to compute the actual Markov model)
   
   - ... But of course this can all be done in a **much** more efficient way using a proper statistical software (e.g. `R` &ndash; see [Practical](../practical/07_MM/))

--

## What if we don't get the trial data?...

- Unfortunately, very often we are **not** in a position of using individual level data

   - Either because we have trial data for "our" study, but not for the comparators
   
   - Or because we do not have access to the ILD for any of the relevant treatments


- In these cases, we need to resort to **sub-optimal** methods of analysis

   - Specifically, we can use published summaries to obtain "pseudo-data" based on published Kaplan-Meier estimates
   
   - This practices is becoming very popular and is often termed as "modelling based on **digitised** data"

---


# Digitised data

- Use specialised software to extract data values from published graphs

   - Example: `r icon::fontawesome("firefox") ` [DigitizeIT](https://www.digitizeit.xyz/)
   
--

- Point & click on the curves from published papers

- Save suitable text files that can be fed to appropriate `R` scripts and algorithms to reconstruct the underlying Kaplan Meier curves (`r icon::fontawesome("firefox") ` [Guyot et al, 2012]( http://www.biomedcentral.com/1471-2288/12/9))

`r include_fig("digitised.png",width="85%")`

---

count: false
# Digitised data

## What's wrong with that?...

The problem is that often published papers report data on PFS and OS, **BUT**:

1. The curves are reported **separately** and **independently**
   - Although the data are correlated, because it is the same individuals undergoing the various transitions, there is no way to recover this level of correlation from the digitised data
   
2. The reported curves do not allow to control/stratify for a large number of covariates
   - It is possible that KM curves are reported, say, for males and females, separately; but stratification for many other variables is rare
   
3. It is then impossible to subset the underlying data and estimate all the relevant transition probabilities!

--

`r vspace("40px")`

So?... $\Rightarrow$ .blue[**Partitioned Survival Modelling**]

---

# Partitioned Survival Modelling (PSM)

### See `r icon::fontawesome("firefox") ` [NICE DSU report](http://scharr.dept.shef.ac.uk/nicedsu/wp-content/uploads/sites/7/2017/06/Partitioned-Survival-Analysis-final-report.pdf)
```{r echo=F,fig.width=12,fig.height=7,opts=list(width="75%",title="The survival curves for OS and PFS can be used to derive the proportion of individuals who at each time point are progressed as the difference between the other two: if you are not dead and you are not in progression free, then you are progressed...")}
load("~/Dropbox/UCL/3021/Lectures/figs/Pembro_PFS_OS.Rdata")
os=os %>% as_tibble() %>% rename(t=V1,S=OSplottest)
pfs=pfs %>% as_tibble() %>% rename(t=V1,S=PFSplottest)
os %>% mutate(label="Overall survival") %>% 
  bind_rows(
    pfs %>% mutate(label="Progression free survival")
  ) %>% 
  bind_rows(
    (os-pfs) %>% mutate(
      label="Progressed",
      t=os$t
    )
  ) %>% ggplot(aes(x=t,y=S,color=label)) + geom_line(size=1.2) + theme_bw() +
  labs(x="Time",y="Survival",color="") +
  xlim(0,700) + theme(legend.text=element_text(size=12)) +
  theme(axis.line = element_line(colour = "black"),
          panel.background = element_blank(),
          panel.border = element_blank(),
          plot.title = element_text(size=18, face="bold")) +
  scale_color_discrete(breaks=c("Progression free survival","Progressed","Overall survival"))
```

<!--
`r include_fig("PartSA.png",width="57%",title="The survival curves for OS and PFS can be used to derive the proportion of individuals who at each time point are progressed as the difference between the other two: if you are not dead and you are not in progression free, then you are progressed...")`
-->

---

count: false
# Partitioned Survival Modelling (PSM)

### See `r icon::fontawesome("firefox") ` [NICE DSU report](http://scharr.dept.shef.ac.uk/nicedsu/wp-content/uploads/sites/7/2017/06/Partitioned-Survival-Analysis-final-report.pdf)

```{r echo=F,fig.width=12,fig.height=7,opts=list(width="75%",title="This representation makes it even clearer")}

os %>% mutate(label="Overall survival") %>% 
  bind_rows(
    pfs %>% mutate(label="Progression free survival")
  )  %>% ggplot(aes(x=t,y=S,color=label)) + geom_line(size=1.2) + theme_bw() +
  labs(x="Time",y="Survival",color="") +
  xlim(0,300) + theme(legend.position = "none") +
  geom_hline(yintercept=1,linetype="dashed") +
  geom_segment(aes(x = 52, y = 0, xend = 52, yend = pfs %>% filter(t==52) %>% pull(S)),
                  arrow = arrow(ends="both",length = unit(0.15, "cm"),type="closed"),color="black",size=.2) +
  geom_segment(aes(x = 52, y = pfs %>% filter(t==52) %>% pull(S), xend = 52, yend = os %>% filter(t==52) %>% pull(S)),
                  arrow = arrow(ends="both",length = unit(0.15, "cm"),type="closed"),color="black",size=.2) +
  geom_segment(aes(x = 52, y = os %>% filter(t==52) %>% pull(S), xend = 52, yend = 1),
                  arrow = arrow(ends="both",length = unit(0.15, "cm"),type="closed"),color="black",size=.2) +
  annotate("text",x=52,y=pfs %>% filter(t==52) %>% pull(S)/2,label="PFS(t)",hjust=1.2) +
  annotate("text",x=52,y=(os %>% filter(t==52) %>% pull(S)+pfs %>% filter(t==52) %>% pull(S))/2,label="OS(t)-PFS(t)",hjust=-.2) +
  annotate("text",x=52,y=(1+os %>% filter(t==52) %>% pull(S))/2,label="1-OS(t)",hjust=-.2) +
  theme(axis.line = element_line(colour = "black"),
          panel.background = element_blank(),
          panel.border = element_blank(),
          plot.title = element_text(size=18, face="bold"))
```


<!--
`r include_fig("PartSA2.png",width="57%",title="This representation makes it even clearer")`
-->
---

# Markov models and PSM

```{r 3state2, engine='tikz', echo=F, out.width="85%",opts=list(width="75%",title="INSERT TEXT HERE"), eval=FALSE}
\input{../assets/latex_colours.tex}
\usetikzlibrary{shapes,arrows,arrows.meta,decorations.pathreplacing,shapes.geometric}

\begin{tikzpicture}
\draw(0,2) node[align=center,ellipse,draw,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](1){Progression};
\draw(-2.5,0) node[align=center,ellipse,draw,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](2){Pre progression};
\draw(2.5,0) node[align=center,ellipse,draw,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](3){Death};

\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (2.40) -- (1.200);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (2.east) -- (3.west);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (1.330) -- (3.140);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (1) to [out=190, in=170, looseness=3.5] (1);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (2) to [out=188, in=173, looseness=3.5] (2);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (3) to [out=345, in=20, looseness=3.5] (3);

\draw(-4.5,0) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](6){$\lambda_{11}$};
\draw(-1.65,1.15) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](7){$\lambda_{12}$};
\draw(.4,.2) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](9){$\lambda_{13}$};
\draw(-1.7,2.1) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](5){$\lambda_{22}$};
\draw(1.6,1.15) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](8){$\lambda_{23}$};
\draw(4,0) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](10){$\lambda_{33}$};

\draw(2.55,-.5) node[align=center,fill=none,font=\sffamily\fontsize{6}{7}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=white](10){$\pi_{3}^{(t)}=1-\mbox{OS}(t)$};
\draw(-2.55,-.5) node[align=center,fill=none,font=\sffamily\fontsize{6}{7}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=white](6){$\pi_{1}^{(t)}=\mbox{PFS}(t)$};
\draw(.15,2.5) node[align=center,fill=none,font=\sffamily\fontsize{6}{7}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=white](6){$\pi_{2}^{(t)}=\mbox{OS}(t)-\mbox{PFS}(t)$};
\end{tikzpicture}
```

`r include_fig("3state2-1.png",width="85%")`

`r vspace("-20px")`

## Problem
- **Ideally**, want to estimate the transition probabilities $\bm\lambda$ to run the MM

- But, we're likely to only have access to (most likely digitised!) data on PFS/OS **separately**

   - PFS data record transition to either progression **or** death
   
   - **Digitised** OS data conflate $\lambda_{12}$, $\lambda_{13}$ and $\lambda_{23}$
   
---

count: false
# Markov models and PSM

```{r 3state3, engine='tikz', echo=F, out.width="85%",opts=list(width="75%",title="INSERT TEXT HERE"), eval=FALSE}
\input{../assets/latex_colours.tex}
\usetikzlibrary{shapes,arrows,arrows.meta,decorations.pathreplacing,shapes.geometric}

\begin{tikzpicture}
\draw(0,2) node[align=center,ellipse,draw,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](1){Progression};
\draw(-2.5,0) node[align=center,ellipse,draw,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](2){Pre progression};
\draw(2.5,0) node[align=center,ellipse,draw,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm](3){Death};

\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (2.40) -- (1.200);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (2.east) -- (3.west);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (1.330) -- (3.140);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (1) to [out=190, in=170, looseness=3.5] (1);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (2) to [out=188, in=173, looseness=3.5] (2);
\draw [->,>=latex,shorten >=0pt,auto,node distance=3cm,ultra thin] (3) to [out=345, in=20, looseness=3.5] (3);

\draw(-4.5,0) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=gray!20](6){$\lambda_{11}$};
\draw(-1.65,1.15) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=gray!20](7){$\lambda_{12}$};
\draw(.4,.2) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=gray!20](9){$\lambda_{13}$};
\draw(-1.7,2.1) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=gray!20](5){$\lambda_{22}$};
\draw(1.6,1.15) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=gray!20](8){$\lambda_{23}$};
\draw(4,0) node[align=center,fill=none,font=\sffamily\fontsize{9}{10}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=gray!20](10){$\lambda_{33}$};

\draw(2.55,-.5) node[align=center,fill=none,font=\sffamily\fontsize{6}{7}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=red!70](10){$\pi_{3}^{(t)}=1-\mbox{OS}(t)$};
\draw(-2.55,-.5) node[align=center,fill=none,font=\sffamily\fontsize{6}{7}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=red!70](6){$\pi_{1}^{(t)}=\mbox{PFS}(t)$};
\draw(.15,2.5) node[align=center,fill=none,font=\sffamily\fontsize{6}{7}\selectfont,minimum width=1.8cm,minimum height=.7cm,color=red!70](6){$\pi_{2}^{(t)}=\mbox{OS}(t)-\mbox{PFS}(t)$};
\end{tikzpicture}
```

`r include_fig("3state3-1.png",width="85%")`

`r vspace("-20px")`

## (PSM) Solution

- Can estimate the .red[**proportion of people in each state**] at each time point

   - Basically run the simulation to attach costs & utilities to the number of individuals in each state at each time
   
   - **NB**: Partitioned survival analysis only applies for diseases where patients can only move .red[forward]
   
   - In a partitioned survival analysis, mortality is determined by time-to-death and not linked to concurring event

---

# Conclusions & further tools

- MMs are ubiquitous in health economic evaluation and HTA

- Once the transition probabilities have been estimated, the actual MM part is fairly easy
   - Based on matrix algebra &ndash; even Excel can handle it (in combination with statistical software for the main analysis...)
   - **But**: .red[**much**] more efficient to run the whole process through proper statistical software!

.content-box-beamer[
### Further tools

`r icon::fontawesome("r-project")` [heemod](https://cran.r-project.org/web/packages/heemod/index.html)

   - A general purpose package to run the whole MM process in <tt>R</tt> (can be linked to `BCEA`, but fundamentally a frequentist analysis)

`r icon::fontawesome("r-project")` [hesim](https://cran.r-project.org/web/packages/hesim/index.html)

   - A modular and computationally efficient <tt>R</tt> package for MMs; supports `r icon::academicons("doi")` [cohort discrete time state transition models](doi:10.2165/00019053-199813040-00003), `r icon::academicons("doi")` [partitioned survival models](https://doi.org/10.1002/sim.4780091106) and `r icon::academicons("doi")` [individual-level continuous time state transition models](https://doi.org/10.1016/j.jval.2012.06.014)

`r icon::fontawesome("firefox")` [Cost-effectiveness analysis in `R` using multi-state modelling](https://www.gla.ac.uk/researchinstitutes/healthwellbeing/research/hehta/reports/cwilliams/) 

   - A set of <tt>R</tt> scripts to run analyses based on individual level data (similar to the analysis shown in these slides + even more complex modelling structures)

`r bmhe("5.4")` 
`r vspace("15px")`

   - (**NB** This includes a relatively old example, based on a [cohort discrete time state transition models](doi:10.2165/00019053-199813040-00003), `r icon::academicons("doi")`, but it's useful to have a look to!)

]


`r vspace("2em")`

.alignright[.small[`r icon::fontawesome("arrow-circle-right")` [Next lecture](../11_VoI/index.html)]]
